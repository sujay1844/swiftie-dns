package swiftiedns

import (
	"fmt"
	"log"
	"strconv"
	"strings"

	"github.com/miekg/dns"
)

// Generated by Claude, idc
// unescapeDNSName removes escape sequences from DNS server names
func unescapeDNSName(name string) string {
	// Handle backslash-escaped names
	if strings.Contains(name, "\\") {
		// Remove backslashes before spaces and other special characters
		name = strings.ReplaceAll(name, "\\", "")
	}

	// If you need more complex unescaping (like handling octal or hex escapes)
	return unescapeOctalHex(name)
}

// unescapeOctalHex handles more complex escape sequences
func unescapeOctalHex(name string) string {
	var result strings.Builder
	for i := 0; i < len(name); i++ {
		if name[i] == '\\' && i+1 < len(name) {
			switch name[i+1] {
			case 'x', 'X': // Hex escape
				if i+3 < len(name) {
					if hex, err := strconv.ParseInt(name[i+2:i+4], 16, 32); err == nil {
						result.WriteRune(rune(hex))
						i += 3
						continue
					}
				}
			case '0', '1', '2', '3', '4', '5', '6', '7': // Octal escape
				if i+3 < len(name) {
					if octal, err := strconv.ParseInt(name[i+1:i+4], 8, 32); err == nil {
						result.WriteRune(rune(octal))
						i += 3
						continue
					}
				}
			}
		}
		result.WriteRune(rune(name[i]))
	}
	return result.String()
}

func HandleDNSRequest(songs Songs) dns.HandlerFunc {
	return func(w dns.ResponseWriter, r *dns.Msg) {

		msg := dns.Msg{}
		msg.SetReply(r)
		msg.Authoritative = true

		for _, question := range r.Question {
			log.Printf("Received query for: %s, Type: %d", question.Name, question.Qtype)

			name := strings.TrimSuffix(question.Name, ".")
			name = unescapeDNSName(name)

			responses, err := getResponses(songs, name)
			if err != nil {
				if err == ErrNoSongFound {
					handleNoSongFound(w, r, question, err)
					return
				}
				log.Printf("Failed to get responses: %v", err)
				continue
			}
			for _, responseText := range responses {
				rr, err := dns.NewRR(fmt.Sprintf("%s 3600 IN TXT \"%s\"", question.Name, responseText))
				if err != nil {
					log.Printf("Failed to create TXT record: %v", err)
					continue
				}
				msg.Answer = append(msg.Answer, rr)
			}
		}

		err := w.WriteMsg(&msg)
		if err != nil {
			log.Printf("Failed to send response: %v", err)
		}
	}
}

func handleNoSongFound(w dns.ResponseWriter, r *dns.Msg, question dns.Question, err error) {
	msg := dns.Msg{}
	msg.SetReply(r)
	msg.Authoritative = true

	rr, err := dns.NewRR(fmt.Sprintf("%s 3600 IN TXT \"%s\"", question.Name, err.Error()))
	if err != nil {
		log.Printf("Failed to create TXT record: %v", err)
	}
	msg.Answer = append(msg.Answer, rr)
	err = w.WriteMsg(&msg)
	if err != nil {
		log.Printf("Failed to send response: %v", err)
	}

}
